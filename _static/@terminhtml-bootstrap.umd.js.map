{"version":3,"file":"@terminhtml-bootstrap.umd.js","sources":["../src/bootstrap.ts","../src/index.ts"],"sourcesContent":["const terminHTMLMajorVersion = 1;\nconst terminHTMLUrl = `https://unpkg.com/terminhtml@${terminHTMLMajorVersion}.x/dist/`;\nconst terminHTMLJSUrl = `${terminHTMLUrl}terminhtml.es.js`;\nconst termynalCSSUrl = `${terminHTMLUrl}src/termynal.css`;\n\nimport type { TerminHTML } from \"terminhtml\";\n\ntype TerminHTMLClass = typeof TerminHTML;\ntype TerminHTMLModule = { TerminHTML: TerminHTMLClass };\n\nexport type BootstrapOptions = {\n  className: string;\n  importFromUrl: boolean;\n};\n\nexport type BootstrapResult = {\n  stopListener(): void;\n  terminHTMLs: TerminHTML[];\n};\n\nconst defaultClass = \"terminhtml\";\nconst defaultOptions: BootstrapOptions = {\n  className: defaultClass,\n  importFromUrl: true,\n};\n\nexport function bootstrapTerminHTMLsOnWindowLoad(\n  options?: Partial<BootstrapOptions>\n): void {\n  const { className, importFromUrl } = getOptions(options);\n  // Kick off loading of JS/CSS async\n  const TerminHTMLPromise = loadTerminHTML(importFromUrl);\n  // Immediately add the event listener, but don't fire bootstrap until JS/CSS is loaded\n  window.addEventListener(\"DOMContentLoaded\", () => {\n    TerminHTMLPromise.then(TerminHTML => {\n      createTerminHTMLs(className, TerminHTML);\n    }).catch(console.error);\n  });\n}\n\nexport async function bootstrapTerminHTMLs(\n  options?: Partial<BootstrapOptions>\n): Promise<BootstrapResult> {\n  const { className, importFromUrl } = getOptions(options);\n  const TerminHTML = await loadTerminHTML(importFromUrl);\n\n  return createTerminHTMLs(className, TerminHTML);\n}\n\nfunction getOptions(options?: Partial<BootstrapOptions>): BootstrapOptions {\n  return { ...defaultOptions, ...options };\n}\n\n/**\n * Get the TerminHTML class constructor. If importFromUrl is true, then\n * dynamically load from the latest major version of terminhtml-js via URL.\n * If importFromUrl is false, then use the local version in node_modules.\n */\nfunction getTerminHTMLClass(importFromUrl = true): Promise<TerminHTMLClass> {\n  if (importFromUrl) {\n    // Dynamically load the latest major version of terminhtml-js, so that we can\n    // update end users by only updating terminhtml-js.\n    return import(\n      /* @vite-ignore */\n      terminHTMLJSUrl\n    )\n      .then(({ TerminHTML }: TerminHTMLModule) => TerminHTML)\n      .catch(console.error) as Promise<TerminHTMLClass>;\n  } else {\n    return import(\n      /* @vite-ignore */\n      \"terminhtml\"\n    )\n      .then(({ TerminHTML }: TerminHTMLModule) => TerminHTML)\n      .catch(console.error) as Promise<TerminHTMLClass>;\n  }\n}\n\nasync function loadTerminHTML(importFromUrl = true): Promise<TerminHTMLClass> {\n  // Kick off loading of JS async\n  const TerminHTMLPromise = getTerminHTMLClass(importFromUrl);\n  // Kick off loading of CSS async\n  loadTerminHTMLCSS();\n  // Wait for JS to finish\n  const TerminHTML = await TerminHTMLPromise;\n  return TerminHTML;\n}\n\nfunction createTerminHTMLs(\n  className: string,\n  TerminHTML: TerminHTMLClass\n): BootstrapResult {\n  const elements = document.querySelectorAll<HTMLElement>(`.${className}`);\n  const terminHTMLs: TerminHTML[] = [];\n  for (const element of elements) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n    const terminHTML: TerminHTML = new TerminHTML(element);\n    terminHTMLs.push(terminHTML);\n  }\n  let unloadedTerms = [...terminHTMLs];\n\n  function loadVisibleTermynals() {\n    unloadedTerms = unloadedTerms.filter(term => {\n      if (term.container.getBoundingClientRect().top - innerHeight <= 0) {\n        term.init();\n        return false;\n      }\n      return true;\n    });\n  }\n\n  window.addEventListener(\"scroll\", loadVisibleTermynals);\n  const stopListener = () =>\n    window.removeEventListener(\"scroll\", loadVisibleTermynals);\n  setTimeout(loadVisibleTermynals, 50);\n  return { stopListener, terminHTMLs };\n}\n\nconst cssId = \"terminhtml-styles\";\n\nfunction loadTerminHTMLCSS() {\n  if (!document.getElementById(cssId)) {\n    const head = document.getElementsByTagName(\"head\")[0];\n    const link = document.createElement(\"link\");\n    link.id = cssId;\n    link.rel = \"stylesheet\";\n    link.type = \"text/css\";\n    link.href = termynalCSSUrl;\n    link.media = \"all\";\n    head.appendChild(link);\n  }\n}\n","import { bootstrapTerminHTMLsOnWindowLoad } from \"./bootstrap\";\n\nbootstrapTerminHTMLsOnWindowLoad();\n"],"names":[],"mappings":"obACA,KAAM,GAAgB,gCAAgC,YAChD,EAAkB,GAAG,oBACrB,EAAiB,GAAG,oBAkBpB,EAAmC,CACvC,UAFmB,aAGnB,cAAe,EACjB,EAEO,WACL,EACM,CACN,KAAM,CAAE,YAAW,iBAAkB,EAAW,CAAO,EAEjD,EAAoB,EAAe,CAAa,EAE/C,OAAA,iBAAiB,mBAAoB,IAAM,CAChD,EAAkB,KAAK,AAAc,GAAA,CACnC,EAAkB,EAAW,CAAU,CACxC,CAAA,EAAE,MAAM,QAAQ,KAAK,CAAA,CACvB,CACH,CAWA,WAAoB,EAAuD,CAClE,MAAA,QAAK,GAAmB,EACjC,CAOA,WAA4B,EAAgB,GAAgC,CAC1E,MAAI,GAGK,OAEL,GAEC,KAAK,CAAC,CAAE,gBAAmC,CAAU,EACrD,MAAM,QAAQ,KAAK,EAEf,OAEL,cAEC,KAAK,CAAC,CAAE,gBAAmC,CAAU,EACrD,MAAM,QAAQ,KAAK,CAE1B,CAEA,iBAA8B,EAAgB,GAAgC,CAEtE,KAAA,GAAoB,EAAmB,CAAa,EAExC,WAEC,KAAM,EAE3B,CAEA,WACE,EACA,EACiB,CACjB,KAAM,GAAW,SAAS,iBAA8B,IAAI,GAAW,EACjE,EAA4B,CAAA,EAClC,SAAW,KAAW,GAAU,CAExB,KAAA,GAAyB,GAAI,GAAW,CAAO,EACrD,EAAY,KAAK,CAAU,CAC7B,CACI,GAAA,GAAgB,CAAC,GAAG,CAAW,EAEH,YAAA,CACd,EAAA,EAAc,OAAO,AAAQ,GACvC,EAAK,UAAU,sBAAwB,EAAA,IAAM,aAAe,EAC9D,GAAK,KAAK,EACH,IAEF,EACR,CACH,CAEO,OAAA,iBAAiB,SAAU,CAAoB,EACtD,KAAM,GAAe,IACnB,OAAO,oBAAoB,SAAU,CAAoB,EAC3D,kBAAW,EAAsB,EAAE,EAC5B,CAAE,eAAc,cACzB,CAEA,KAAM,GAAQ,oBAEd,YAA6B,CAC3B,GAAI,CAAC,SAAS,eAAe,CAAK,EAAG,CACnC,KAAM,GAAO,SAAS,qBAAqB,MAAM,EAAE,GAC7C,EAAO,SAAS,cAAc,MAAM,EAC1C,EAAK,GAAK,EACV,EAAK,IAAM,aACX,EAAK,KAAO,WACZ,EAAK,KAAO,EACZ,EAAK,MAAQ,MACb,EAAK,YAAY,CAAI,CACvB,CACF,CCjIA,EAAiC"}